 大牛人
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = Workspace.CurrentCamera

-- 加载 WindUI（兼容不同注入器）
local success, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not success then
    warn("WindUI加载失败，脚本无法运行：" .. WindUI)
    return
end

-- 关闭摄像机震动
pcall(function()
    local ok, main = pcall(function()
        return require(ReplicatedStorage:FindFirstChild("Util") and ReplicatedStorage.Util:FindFirstChild("CameraShaker") and ReplicatedStorage.Util.CameraShaker:FindFirstChild("Main") or nil)
    end)
    if ok and type(main) == "table" then
        local returnnil = function() return nil end
        main.StartShake = returnnil
        main.ShakeOnce = returnnil
        main.ShakeSustain = returnnil
        main.CameraShakeInstance = returnnil
        main.Shake = returnnil
        main.Start = returnnil
    end
end)

-- 通知加载
pcall(function()
    StarterGui:SetCore("SendNotification",{
        Title = "大牛人脚本",
        Text = "加载中...",
        Duration = 3,
    })
end)

-- 全局设置
local _ENV = (getgenv or getrenv or getfenv)()
local MIN_CLICK_DELAY = 0.0005
local Settings = {AutoClick = true, ClickDelay = 0.3} -- 攻速 0.3
local _G = _G or getfenv(0)._G
_G.FastAttack = _G.FastAttack ~= nil and _G.FastAttack or true
-- 初始化ToggleStates并默认开启自动V3
_G.ToggleStates = _G.ToggleStates or {}
_G.ToggleStates["自动V3"] = true -- 默认开启自动V3
_G.AutoBuso = _G.AutoBuso or true -- 默认开启自动武装色霸气

-- 补充缺失的 onCharacterAdded 函数（避免语法错误）
local function onCharacterAdded(char)
    -- 空函数占位，不影响原有逻辑
end

-- Helper
local function SafeWaitForChild(parent, childName, timeout)
    timeout = timeout or 10
    local ok, res = pcall(function() return parent:WaitForChild(childName, timeout) end)
    if ok then return res end
    return nil
end

local function IsAlive(character)
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health and humanoid.Health > 0
end

local function GetRandomValidPart(target)
    if not target then return nil end
    local allParts = target:GetDescendants()
    local validParts = {}
    local humanoidRootPart = target:FindFirstChild("HumanoidRootPart")
    local boneParts = humanoidRootPart and humanoidRootPart.Parent and humanoidRootPart.Parent:GetDescendants() or {}
    for _, part in ipairs(allParts) do
        if part:IsA("BasePart") and part.CanCollide and table.find(boneParts, part) then
            table.insert(validParts, part)
        end
    end
    return #validParts > 0 and validParts[math.random(1, #validParts)] or target:FindFirstChild("HumanoidRootPart")
end

-- 检索核心组件
local function CheckAndGetCoreComponents()
    local Remotes, Modules, Net, RegisterAttack, RegisterHit, Enemies = nil, nil, nil, nil, nil, nil
    while true do
        Remotes = SafeWaitForChild(ReplicatedStorage, "Remotes", 2)
        Modules = SafeWaitForChild(ReplicatedStorage, "Modules", 2)
        Net = Modules and SafeWaitForChild(Modules, "Net", 2) or nil
        RegisterAttack = Net and SafeWaitForChild(Net, "RE/RegisterAttack", 2) or nil
        RegisterHit = Net and SafeWaitForChild(Net, "RE/RegisterHit", 2) or nil
        Enemies = SafeWaitForChild(Workspace, "Enemies", 2)
        if Remotes and Modules and Net and RegisterAttack and RegisterHit and Enemies then
            return Remotes, Net, RegisterAttack, RegisterHit, Enemies
        end
        task.wait(1)
    end
end

-- FastAttack 模块（距离 2500）
local Module = {}
Module.FastAttack = (function()
    if _ENV.rz_FastAttack then return _ENV.rz_FastAttack end
    local FastAttack = {
        Distance = 2500, -- 距离 2500
        attackMobs = true,
        attackPlayers = true,
        Equipped = nil,
        IsRunning = _G.FastAttack,
        consecutiveFailures = 0,
        maxConsecutiveFailures = 5
    }

    local function ProcessEnemies(OthersEnemies, Folder)
        if not Folder or not FastAttack.attackMobs then return nil end
        local BasePart = nil
        for _, Enemy in ipairs(Folder:GetChildren()) do
            if Enemy == LocalPlayer.Character or not IsAlive(Enemy) then continue end
            local foundPart = GetRandomValidPart(Enemy)
            if foundPart and (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (LocalPlayer.Character.HumanoidRootPart.Position - foundPart.Position).Magnitude < FastAttack.Distance) then
                table.insert(OthersEnemies, {Enemy, foundPart})
                BasePart = foundPart
            end
        end
        return BasePart
    end

    local function ProcessRealPlayers(OthersEnemies)
        if not FastAttack.attackPlayers then return nil end
        local BasePart = nil
        for _, OtherPlayer in ipairs(Players:GetPlayers()) do
            if OtherPlayer == LocalPlayer then continue end
            local OtherChar = OtherPlayer.Character
            if not IsAlive(OtherChar) then continue end
            local foundPart = GetRandomValidPart(OtherChar)
            if foundPart and (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (LocalPlayer.Character.HumanoidRootPart.Position - foundPart.Position).Magnitude < FastAttack.Distance) then
                table.insert(OthersEnemies, {OtherChar, foundPart})
                BasePart = foundPart
            end
        end
        return BasePart
    end

    function FastAttack:Attack(BasePart, OthersEnemies)
        local _, Net, temp_RegisterAttack, temp_RegisterHit, _ = CheckAndGetCoreComponents()
        if not (BasePart and OthersEnemies and #OthersEnemies > 0 and temp_RegisterAttack and temp_RegisterHit) then
            self.consecutiveFailures = self.consecutiveFailures + 1
            if self.consecutiveFailures >= self.maxConsecutiveFailures then
                self.consecutiveFailures = 0
                self.Equipped = LocalPlayer.Character and IsAlive(LocalPlayer.Character) and LocalPlayer.Character:FindFirstChildOfClass("Tool")
            end
            task.delay(0.5, function() self:AttackNearest() end)
            return
        end
        self.consecutiveFailures = 0
        temp_RegisterAttack:FireServer(Settings.ClickDelay or MIN_CLICK_DELAY)
        temp_RegisterHit:FireServer(BasePart, OthersEnemies)
    end

    function FastAttack:AttackNearest()
        if not self.IsRunning then return end
        local _, _, _, _, Enemies = CheckAndGetCoreComponents()
        local OthersEnemies = {}
        local Part1 = ProcessEnemies(OthersEnemies, Enemies)
        local Part2 = ProcessRealPlayers(OthersEnemies)
        if #OthersEnemies > 0 then
            self:Attack(Part1 or Part2, OthersEnemies)
        end
    end

    function FastAttack:BladeHits()
        if not self.IsRunning then return end
        local Equipped = LocalPlayer.Character and IsAlive(LocalPlayer.Character) and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if Equipped and Equipped.ToolTip ~= "Gun" then
            self:AttackNearest()
        end
    end

    task.spawn(function()
        while true do
            task.wait(Settings.ClickDelay)
            if Settings.AutoClick and FastAttack.IsRunning then
                FastAttack:BladeHits()
            else
                task.wait()
            end
        end
    end)

    _ENV.rz_FastAttack = FastAttack
    return FastAttack
end)()

-- 恢复逻辑
task.spawn(function()
    while true do
        task.wait(1)
        if not _ENV.rz_FastAttack then
            while not _ENV.rz_FastAttack do
                task.wait(0.5)
                if _G.FastAttack then
                    _ENV.rz_FastAttack = Module.FastAttack or _ENV.rz_FastAttack
                end
            end
        end
    end
end)

-- ========== 修复后的自动V4逻辑（删除重复定义，保留一处） ==========
local autoV4Task = nil
local autoV4State = false -- 统一管理状态
local function callAwakeningRemote()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    -- 优先从角色身上找Awakening（装备状态），再从背包找
    local Awakening = character:FindFirstChild("Awakening") or LocalPlayer.Backpack:FindFirstChild("Awakening")
    if not Awakening then return end
    
    local RemoteFunc = Awakening:FindFirstChildOfClass("RemoteFunction")
    if not RemoteFunc then return end
    
    -- 增加重试机制，提升调用成功率
    local success, result = pcall(function()
        return RemoteFunc:InvokeServer("AwakenV4", true)
    end)
    
    if not success then
        warn("V4觉醒调用失败:", result)
        -- 失败后0.5秒重试一次
        task.delay(0.5, function()
            pcall(function()
                RemoteFunc:InvokeServer("AwakenV4", true)
            end)
        end)
    end
end

-- 绑定事件：首次加载+每次复活都触发
local localPlayer = game.Players.LocalPlayer
if localPlayer.Character then
    onCharacterAdded(localPlayer.Character)
end
localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- 自动武装色霸气核心逻辑
local isDead = false
local function activateBusoIfNeeded(char)
    if not char or not _G.AutoBuso then return end
    
    -- 确保角色存活且有人类oid
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        isDead = true
        return
    end
    
    -- 检测到角色从死亡变为存活（复活）
    if isDead then
        isDead = false
        -- 复活后短暂延迟，等角色加载完成
        task.wait(0.5)
    end
    
    -- 激活武装色的核心条件
    if CollectionService:HasTag(char, "Buso") and not char:FindFirstChild("HasBuso") then
        local success, err = pcall(function()
            local commRemote = ReplicatedStorage:FindFirstChild("Remotes"):FindFirstChild("CommF_")
            if commRemote then
                commRemote:InvokeServer("Buso")
            end
        end)
        if not success then
            warn("激活武装色失败:", err)
        end
    end
end

-- 1. 每帧检测（基础逻辑）
RunService.Heartbeat:Connect(function()
    local char = LocalPlayer.Character
    activateBusoIfNeeded(char)
end)

-- 2. 监听角色加载事件（专门针对复活/角色切换）
LocalPlayer.CharacterAdded:Connect(function(newChar)
    isDead = false -- 角色加载完成，标记为存活
    -- 复活后延迟检测，确保角色完全加载
    task.wait(1)
    activateBusoIfNeeded(newChar)
end)

-- 自动V3默认启动
local autoV3Task = nil
local function callRaceV3Remote()
    local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
    if not Remotes then return end
    local CommE = Remotes:FindFirstChild("CommE")
    if not CommE then return end
    pcall(function()
        CommE:FireServer("ActivateAbility")
    end)
end

if _G.ToggleStates["自动V3"] then
    autoV3Task = task.spawn(function()
        while _G.ToggleStates["自动V3"] do
            callRaceV3Remote()
            task.wait(1)
        end
        autoV3Task = nil
    end)
end

-- 移动加速
getfenv().translateSpeed = 50
getfenv().translateAccelEnabled = false
getfenv().translateConnection = nil

local function enableTranslateAccel(enabled)
    getfenv().translateAccelEnabled = enabled
    if enabled then
        if getfenv().translateConnection then getfenv().translateConnection:Disconnect(); getfenv().translateConnection = nil end
        getfenv().translateConnection = RunService.Heartbeat:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("Humanoid") and char:FindFirstChild("HumanoidRootPart") then
                local humanoid = char.Humanoid
                if humanoid.MoveDirection.Magnitude > 0 then
                    local moveDirection = humanoid.MoveDirection
                    local acceleration = moveDirection * (getfenv().translateSpeed or 50) / 30
                    char:TranslateBy(acceleration)
                end
            end
        end)
    else
        if getfenv().translateConnection then getfenv().translateConnection:Disconnect(); getfenv().translateConnection = nil end
    end
end

-- ESP（默认开启所有功能）
local ESPConfig = {
    MainSwitch = true, -- ESP总开关默认开启
    ShowNameDistance = true, -- 名字距离默认开启
    ShowTracer = true, -- 射线默认开启
    ShowHealth = true -- 血量默认开启
}

local ESPElements = {}

local function CleanupPlayerESP(player)
    if not ESPElements[player.UserId] then return end
    local e = ESPElements[player.UserId]
    if e.NameHealthESP then
        pcall(function() e.NameHealthESP:Destroy() end)
        e.NameHealthESP = nil
    end
    if e.NameHealthUpdateConn then
        pcall(function() e.NameHealthUpdateConn:Disconnect() end)
        e.NameHealthUpdateConn = nil
    end
    if e.Tracer then
        pcall(function() e.Tracer:Remove() end)
        e.Tracer = nil
    end
    if e.TracerConn then
        pcall(function() e.TracerConn:Disconnect() end)
        e.TracerConn = nil
    end
    ESPElements[player.UserId] = nil
end

local function CreateNameDistanceHealthESP(player)
    if not player.Character or not player.Character:FindFirstChild("Head") then return end
    local head = player.Character.Head
    if ESPElements[player.UserId] and ESPElements[player.UserId].NameHealthESP then
        ESPElements[player.UserId].NameHealthESP:Destroy()
    end

    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "NameDistanceHealthESP"
    billboardGui.Adornee = head
    billboardGui.Size = UDim2.new(0, 120, 0, 50)
    billboardGui.StudsOffset = Vector3.new(0, 3.5, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = head

    local nameLabel = Instance.new("TextLabel", billboardGui)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.Size = UDim2.new(1, 0, 0, 16)
    nameLabel.TextColor3 = Color3.new(1, 1, 1)
    nameLabel.TextScaled = true
    nameLabel.Font = Enum.Font.GothamSemibold

    local healthLabel = Instance.new("TextLabel", billboardGui)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Position = UDim2.new(0, 0, 0.33, 0)
    healthLabel.Size = UDim2.new(1, 0, 0, 16)
    healthLabel.TextColor3 = Color3.new(0, 1, 0)
    healthLabel.TextScaled = true
    healthLabel.Font = Enum.Font.Gotham

    local distanceLabel = Instance.new("TextLabel", billboardGui)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Position = UDim2.new(0, 0, 0.66, 0)
    distanceLabel.Size = UDim2.new(1, 0, 0, 16)
    distanceLabel.TextColor3 = Color3.new(1, 0.5, 0)
    distanceLabel.TextScaled = true
    distanceLabel.Font = Enum.Font.Gotham

    local updateConnection = RunService.RenderStepped:Connect(function()
        if not billboardGui.Parent or not LocalPlayer.Character or not player.Character then return end
        local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
        if localRoot and targetRoot then
            local distance = (localRoot.Position - targetRoot.Position).Magnitude
            distanceLabel.Text = string.format("%.1f米", distance)
        end
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            local health = math.floor(humanoid.Health)
            local maxHealth = math.floor(humanoid.MaxHealth)
            local healthPercent = (maxHealth > 0) and (health / maxHealth) or 0
            if healthPercent > 0.7 then
                healthLabel.TextColor3 = Color3.new(0, 1, 0)
            elseif healthPercent > 0.3 then
                healthLabel.TextColor3 = Color3.new(1, 1, 0)
            else
                healthLabel.TextColor3 = Color3.new(1, 0, 0)
            end
            healthLabel.Text = string.format("血量: %d/%d", health, maxHealth)
        end
    end)

    ESPElements[player.UserId] = ESPElements[player.UserId] or {}
    ESPElements[player.UserId].NameHealthESP = billboardGui
    ESPElements[player.UserId].NameHealthUpdateConn = updateConnection
end

local function CreateTracerESP(player)
    if ESPElements[player.UserId] and ESPElements[player.UserId].Tracer then
        pcall(function() ESPElements[player.UserId].Tracer:Remove() end)
    end
    local tracer = Drawing.new("Line")
    tracer.Color = Color3.new(1, 0, 0)
    tracer.Thickness = 2
    tracer.Transparency = 0.8
    tracer.Visible = false

    local renderConnection = RunService.RenderStepped:Connect(function()
        if not ESPConfig.MainSwitch or not ESPConfig.ShowTracer then
            tracer.Visible = false
            return
        end
        local localChar = LocalPlayer.Character
        local targetChar = player.Character
        if not localChar or not targetChar then tracer.Visible = false; return end
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            local screenPos, isVisible = Camera:WorldToViewportPoint(targetRoot.Position)
            if isVisible then
                tracer.Visible = true
                tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                tracer.To = Vector2.new(screenPos.X, screenPos.Y)
            else
                tracer.Visible = false
            end
        else
            tracer.Visible = false
        end
    end)

    ESPElements[player.UserId] = ESPElements[player.UserId] or {}
    ESPElements[player.UserId].Tracer = tracer
    ESPElements[player.UserId].TracerConn = renderConnection
end

local function UpdatePlayerESP(player)
    if player == LocalPlayer then return end
    if not player.Character then
        CleanupPlayerESP(player)
        return
    end
    if not player.Character:FindFirstChild("Head") or not player.Character:FindFirstChild("HumanoidRootPart") then
        CleanupPlayerESP(player)
        return
    end
    if ESPConfig.MainSwitch then
        if ESPConfig.ShowTracer then CreateTracerESP(player) end
        if ESPConfig.ShowNameDistance or ESPConfig.ShowHealth then
            CreateNameDistanceHealthESP(player)
        else
            if ESPElements[player.UserId] and ESPElements[player.UserId].NameHealthESP then
                pcall(function() ESPElements[player.UserId].NameHealthESP:Destroy() end)
                ESPElements[player.UserId].NameHealthESP = nil
            end
            if ESPElements[player.UserId] and ESPElements[player.UserId].NameHealthUpdateConn then
                pcall(function() ESPElements[player.UserId].NameHealthUpdateConn:Disconnect() end)
                ESPElements[player.UserId].NameHealthUpdateConn = nil
            end
        end
    else
        CleanupPlayerESP(player)
    end
end

local function UpdateAllESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            UpdatePlayerESP(player)
        end
    end
end

-- ESP自动初始化
UpdateAllESP()

Players.PlayerAdded:Connect(function(player)
    if player == LocalPlayer then return end
    if player.Character then
        task.spawn(function() task.wait(0.5); UpdatePlayerESP(player) end)
    end
    player.CharacterAdded:Connect(function() task.spawn(function() task.wait(0.5); UpdatePlayerESP(player) end) end)
    player.CharacterRemoving:Connect(function() CleanupPlayerESP(player) end)
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    UpdateAllESP()
end)

task.spawn(function()
    while true do
        task.wait(3)
        if ESPConfig.MainSwitch then UpdateAllESP() end
    end
end)

-- 传送
local function TeleportTo(position)
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        char.HumanoidRootPart.CFrame = CFrame.new(position)
    end
end

-- ===================== WindUI 界面 =====================
local Window = WindUI:CreateWindow({
    Title = "大牛人脚本",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "大牛人",
    Folder = "DaNiuRen",
    Size = UDim2.fromOffset(580, 650),
    Transparent = true,
    Theme = "Dark",
    User = {
        Enabled = true,
        Callback = function() print("大牛人脚本已激活") end,
    },
    SideBarWidth = 200,
    ScrollBarEnabled = true,
})

-- 顶部按钮
Window:CreateTopbarButton("Refresh", "refresh-ccw", function() 
    WindUI:Notify({
        Title = "刷新成功",
        Content = "脚本功能已重新加载",
        Duration = 2
    })
end, 990)

Window:CreateTopbarButton("Help", "question-circle", function()
    Window:Dialog({
        Title = "使用帮助",
        Content = "按 H 键显示/隐藏界面\n所有功能保持原逻辑不变\n问题请联系作者",
        Buttons = {
            {
                Title = "知道了",
                Variant = "Primary"
            }
        }
    })
end, 989)

-- 打开按钮设置
Window:EditOpenButton({
    Title = "大牛人脚本",
    Icon = "bullhorn",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("FF6B6B"),
        Color3.fromHex("4ECDC4")
    ),
    Draggable = true,
})

-- 创建标签页
local Tabs = {}
do
    Tabs.AttackTab = Window:Tab({ Title = "战斗参数", Icon = "sword" }) -- 攻击设置→战斗参数
    Tabs.MovementTab = Window:Tab({ Title = "移动设置", Icon = "run" })
    Tabs.ESPTab = Window:Tab({ Title = "ESP设置", Icon = "eye" })
    Tabs.TeleportTab = Window:Tab({ Title = "传送功能", Icon = "teleport" })
    Tabs.ScriptsTab = Window:Tab({ Title = "功能2", Icon = "code" })
end

-- ===================== 战斗参数标签页 =====================
Tabs.AttackTab:Paragraph({
    Title = "战斗参数",
    Desc = "调整攻击、武装色等战斗相关设置",
    Image = "sword",
    ImageSize = 40,
    Color = "Red"
})

-- 快速攻击开关
Tabs.AttackTab:Toggle({
    Title = "攻击玩家和怪物",
    Desc = "开启/关闭自动攻击玩家和怪物",
    Value = _G.FastAttack,
    Callback = function(state)
        if _ENV.rz_FastAttack then
            _ENV.rz_FastAttack.IsRunning = state
            _G.FastAttack = state
        else
            _G.FastAttack = state
        end
        WindUI:Notify({ Title = "快速攻击", Content = state and "已开启" or "已关闭", Duration = 1.5 })
    end
})

-- 攻击范围
Tabs.AttackTab:Slider({
    Title = "攻击范围",
    Desc = "调整攻击检测距离（1-5000）",
    Value = {
        Min = 1,
        Max = 5000,
        Default = 2500,
    },
    Callback = function(value)
        local num = math.floor(value)
        if _ENV.rz_FastAttack then
            _ENV.rz_FastAttack.Distance = num
        else
            if Module.FastAttack then Module.FastAttack.Distance = num end
        end
        WindUI:Notify({ Title = "攻击范围", Content = "已设置为: " .. num, Duration = 1.5 })
    end
})

-- 攻击速度
Tabs.AttackTab:Slider({
    Title = "攻击速度",
    Desc = "调整攻击间隔（0.0005-2）",
    Step = 0.01,
    Value = {
        Min = MIN_CLICK_DELAY,
        Max = 2,
        Default = 0.3,
    },
    Callback = function(value)
        Settings.ClickDelay = value
        WindUI:Notify({ Title = "攻击速度", Content = "已设置为: " .. string.format("%.2f", value), Duration = 1.5 })
    end
})

-- 自动点击开关
Tabs.AttackTab:Toggle({
    Title = "自动攻击",
    Desc = "开启后自动持续攻击",
    Value = Settings.AutoClick,
    Callback = function(state)
        Settings.AutoClick = state
        WindUI:Notify({ Title = "自动点击", Content = state and "已开启" or "已关闭", Duration = 1.5 })
    end
})

-- 自动武装色霸气UI开关（默认开启）
Tabs.AttackTab:Toggle({
    Title = "自动武装色霸气",
    Desc = "自动保持武装色开启（含复活自动重开）",
    Value = _G.AutoBuso,
    Callback = function(state)
        _G.AutoBuso = state
        WindUI:Notify({
            Title = "自动武装色霸气",
            Content = state and "已开启" or "已关闭",
            Duration = 1.5
        })
    end
})

-- 自动V4开关
Tabs.AttackTab:Toggle({
    Title = "自动V4",
    Value = autoV4State,
    Callback = function(state)
        _G.ToggleStates["自动V4"] = state
        autoV4State = state
        
        -- 取消原有任务
        if autoV4Task then
            task.cancel(autoV4Task)
            autoV4Task = nil
        end
        
        if state then
            -- 新的循环逻辑：0.98秒调用一次，提升触发频率
            autoV4Task = task.spawn(function()
                while autoV4State do
                    callAwakeningRemote()
                    task.wait(0.98)
                end
                autoV4Task = nil
            end)
            WindUI:Notify({ Title = "自动V4", Content = "已开启", Duration = 1.5 })
        else
            WindUI:Notify({ Title = "自动V4", Content = "已关闭", Duration = 1.5 })
        end
    end
})

-- 自动V3开关（默认开启）
Tabs.AttackTab:Toggle({
    Title = "自动V3",
    Value = _G.ToggleStates["自动V3"],
    Callback = function(state)
        _G.ToggleStates["自动V3"] = state
        if autoV3Task then
            task.cancel(autoV3Task)
            autoV3Task = nil
        end
        if state then
            autoV3Task = task.spawn(function()
                while _G.ToggleStates["自动V3"] do
                    callRaceV3Remote()
                    task.wait(1)
                end
                autoV3Task = nil
            end)
            WindUI:Notify({ Title = "自动V3", Content = "已开启", Duration = 2 })
        else
            WindUI:Notify({ Title = "自动V3", Content = "已关闭", Duration = 2 })
        end
    end
})

-- 摄像机距离
Tabs.AttackTab:Input({
    Title = "摄像机距离",
    Value = tostring(LocalPlayer.CameraMaxZoomDistance or 128),
    Placeholder = "输入数值",
    Callback = function(input)
        local v = tonumber(input)
        if v then
            LocalPlayer.CameraMaxZoomDistance = v
            WindUI:Notify({ Title = "摄像机距离", Content = "已设置为: " .. v, Duration = 1.5 })
        end
    end
})

-- ===================== 移动设置标签页 =====================
Tabs.MovementTab:Paragraph({
    Title = "移动参数",
    Image = "run",
    ImageSize = 40,
    Color = "Green"
})

-- 移速数值
Tabs.MovementTab:Slider({
    Title = "移速强度",
    Desc = "调整移速倍率（1-2000）",
    Value = {
        Min = 1,
        Max = 2000,
        Default = 200,
    },
    Callback = function(value)
        getfenv().translateSpeed = value
        WindUI:Notify({ Title = "移速", Content = "强度已设置为: " .. value, Duration = 1.5 })
    end
})

-- 移速开关
Tabs.MovementTab:Toggle({
    Title = "移速开关",
    Desc = "开启/关闭移速功能",
    Value = false,
    Callback = function(state)
        enableTranslateAccel(state)
        WindUI:Notify({ Title = "移速", Content = state and "已开启" or "已关闭", Duration = 1.5 })
    end
})

-- ===================== ESP设置标签页 =====================
-- ESP总开关（默认开启）
Tabs.ESPTab:Toggle({
    Title = "ESP总开关",
    Desc = "控制所有ESP功能的开启/关闭",
    Value = ESPConfig.MainSwitch,
    Callback = function(state)
        ESPConfig.MainSwitch = state
        UpdateAllESP()
        WindUI:Notify({ Title = "ESP功能", Content = state and "已开启" or "已关闭", Duration = 1.5 })
    end
})

-- ESP名字距离（默认开启）
Tabs.ESPTab:Toggle({
    Title = "显示名字和距离",
    Desc = "显示玩家名字和距离信息",
    Value = ESPConfig.ShowNameDistance,
    Callback = function(state)
        ESPConfig.ShowNameDistance = state
        UpdateAllESP()
    end
})

-- ESP血量（默认开启）
Tabs.ESPTab:Toggle({
    Title = "显示血量",
    Desc = "显示玩家当前血量",
    Value = ESPConfig.ShowHealth,
    Callback = function(state)
        ESPConfig.ShowHealth = state
        UpdateAllESP()
    end
})

-- ESP射线（默认开启）
Tabs.ESPTab:Toggle({
    Title = "显示射线",
    Desc = "显示从屏幕中心到玩家的射线",
    Value = ESPConfig.ShowTracer,
    Callback = function(state)
        ESPConfig.ShowTracer = state
        UpdateAllESP()
    end
})

-- ===================== 传送功能标签页 =====================
local teleportButtons = {
    { "天鹅房间", function() TeleportTo(Vector3.new(-287.37, 305.81, 592.98)) end },
    { "豪宅", function() TeleportTo(Vector3.new(2286.93, 15.06, 910.51)) end },
    { "鬼船", function() TeleportTo(Vector3.new(-6496.89795, 89.0350037,-116.509003)) end },
    { "鬼船外", function() TeleportTo(Vector3.new(920.478027, 154.901001, 32838.9648)) end },
}

for _, btnData in ipairs(teleportButtons) do
    Tabs.TeleportTab:Button({
        Title = btnData[1],
        Variant = "Primary",
        Callback = function()
            btnData[2]()
            WindUI:Notify({ Title = "传送", Content = "已传送到: " .. btnData[1], Duration = 1.5 })
        end
    })
end

-- ===================== 功能2标签页 =====================
local externalScripts = {
    { "Aimbot", "https://raw.githubusercontent.com/98krgqg/aimbot/refs/heads/main/aimbot" },
    { "FPS优化", "https://raw.githubusercontent.com/98krgqg/fps/refs/heads/main/111" },
    { "飞行功能", "https://raw.githubusercontent.com/98krgqg/fly/refs/heads/main/daniu" },
    { "法天象地", "https://raw.githubusercontent.com/98krgqg/ftxd/refs/heads/main/ftxd" },
    { "Bypasstp", "https://raw.githubusercontent.com/98krgqg/tp/refs/heads/main/Bypass" },
    { "删除岩浆", "https://raw.githubusercontent.com/98krgqg/LAVAVAVA/refs/heads/main/NO%20LAVA" },
}

for _, scriptData in ipairs(externalScripts) do
    Tabs.ScriptsTab:Button({
        Title = scriptData[1],
        Variant = "Secondary",
        Callback = function()
            pcall(function()
                loadstring(game:HttpGet(scriptData[2]))()
                WindUI:Notify({ Title = "脚本加载", Content = scriptData[1] .. " 已加载", Duration = 2 })
            end)
        end
    })
end

-- ===================== H 键快捷键设置 =====================
local toggleKey = Enum.KeyCode.H
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == toggleKey then
        if UserInputService:GetFocusedTextBox() then return end
        Window:Toggle()
        WindUI:Notify({
            Title = "界面控制",
            Content = Window:IsOpen() and "界面已显示" or "界面已隐藏",
            Duration = 1.5
        })
    end
end)

-- 启动提示
pcall(function()
    StarterGui:SetCore("SendNotification",{
        Title = "大牛人脚本",
        Text = "大牛人加载完成",
        Duration = 5,
    })
end)

-- 关闭回调
Window:OnClose(function()
    print("大牛人脚本界面已关闭")
end)

return {
    Window = Window,
    FastAttack = _ENV.rz_FastAttack or Module.FastAttack,
    Settings = Settings,
    ESPConfig = ESPConfig
}
